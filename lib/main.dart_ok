import 'package:flutter/material.dart';

// Model untuk Event
class CalendarEvent {
  String id;
  String title;
  DateTime startTime;
  DateTime endTime;
  Color color;

  CalendarEvent({
    required this.id,
    required this.title,
    required this.startTime,
    required this.endTime,
    this.color = Colors.blue,
  });

  CalendarEvent copyWith({
    String? id,
    String? title,
    DateTime? startTime,
    DateTime? endTime,
    Color? color,
  }) {
    return CalendarEvent(
      id: id ?? this.id,
      title: title ?? this.title,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      color: color ?? this.color,
    );
  }
}

// Model untuk layout event (untuk splitting)
class EventLayout {
  CalendarEvent event;
  double left;
  double width;
  int column;
  int totalColumns;

  EventLayout({
    required this.event,
    required this.left,
    required this.width,
    required this.column,
    required this.totalColumns,
  });
}

class DayViewCalendar extends StatefulWidget {
  final DateTime selectedDate;

  const DayViewCalendar({super.key, required this.selectedDate});

  @override
  State<DayViewCalendar> createState() => _DayViewCalendarState();
}

class _DayViewCalendarState extends State<DayViewCalendar> {
  List<CalendarEvent> events = [
    CalendarEvent(
      id: '1',
      title: 'Meeting Tim',
      startTime: DateTime.now().copyWith(hour: 9, minute: 0),
      endTime: DateTime.now().copyWith(hour: 10, minute: 30),
      color: Colors.blue,
    ),
    CalendarEvent(
      id: '2',
      title: 'Presentasi Project',
      startTime: DateTime.now().copyWith(hour: 9, minute: 30),
      endTime: DateTime.now().copyWith(hour: 10, minute: 15),
      color: Colors.green,
    ),
    CalendarEvent(
      id: '3',
      title: 'Review Code',
      startTime: DateTime.now().copyWith(hour: 14, minute: 15),
      endTime: DateTime.now().copyWith(hour: 15, minute: 45),
      color: Colors.orange,
    ),
  ];

  final double hourHeight = 60.0;
  final double timeColumnWidth = 80.0;
  final int minuteInterval = 5; // Interval 5 menit
  late ScrollController _scrollController;

  // Untuk drag indicator
  bool _isDragging = false;
  DateTime? _dragTargetTime;
  CalendarEvent? _draggedEvent;

  @override
  void initState() {
    super.initState();
    _scrollController = ScrollController();

    // Auto scroll ke jam sekarang setelah widget selesai build
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _scrollToCurrentTime();
    });
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  void _scrollToCurrentTime() {
    DateTime now = DateTime.now();
    double targetPosition =
        (now.hour * hourHeight) - 100; // Offset sedikit ke atas
    if (targetPosition < 0) targetPosition = 0;

    _scrollController.animateTo(
      targetPosition,
      duration: const Duration(milliseconds: 500),
      curve: Curves.easeInOut,
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(
          '${widget.selectedDate.day}/${widget.selectedDate.month}/${widget.selectedDate.year}',
        ),
        backgroundColor: Colors.blue,
        foregroundColor: Colors.white,
      ),
      body: SafeArea(
        child: Stack(
          children: [
            SingleChildScrollView(
              controller: _scrollController,
              child: SizedBox(
                height: 24 * hourHeight, // 24 jam
                child: Row(
                  children: [
                    // Kolom Waktu (Hours)
                    _buildTimeColumn(),
                    // Kolom Event
                    Expanded(child: _buildEventColumn()),
                  ],
                ),
              ),
            ),
            // Time indicator
            if (_isDragging && _dragTargetTime != null)
              _buildDragTimeIndicator(),
          ],
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _addNewEvent,
        child: const Icon(Icons.add),
      ),
    );
  }

  Widget _buildTimeColumn() {
    return Container(
      width: timeColumnWidth,
      decoration: BoxDecoration(
        color: Colors.grey.shade50,
        border: Border(
          right: BorderSide(color: Colors.grey.shade300, width: 1),
        ),
      ),
      child: Column(
        children: List.generate(24, (index) {
          return Container(
            height: hourHeight,
            alignment: Alignment.topLeft,
            padding: const EdgeInsets.only(top: 4, left: 8),
            decoration: BoxDecoration(
              border: Border(bottom: BorderSide(color: Colors.grey.shade300)),
            ),
            child: Text(
              '${index.toString().padLeft(2, '0')}:00',
              style: const TextStyle(
                fontSize: 12,
                color: Colors.grey,
                fontWeight: FontWeight.w500,
              ),
            ),
          );
        }),
      ),
    );
  }

  Widget _buildEventColumn() {
    return Container(
      height: 24 * hourHeight, // 24 jam
      child: Stack(
        children: [
          // Grid lines (per 5 menit)
          _buildGridLines(),
          // Current time indicator
          _buildCurrentTimeIndicator(),
          // Events dengan layout splitting
          ..._buildLayoutedEvents(),
          // Overlay DragTarget untuk seluruh area
          _buildOverlayDragTarget(),
        ],
      ),
    );
  }

  Widget _buildGridLines() {
    DateTime now = DateTime.now();
    bool isToday =
        widget.selectedDate.day == now.day &&
        widget.selectedDate.month == now.month &&
        widget.selectedDate.year == now.year;

    List<Widget> gridLines = [];

    // Generate grid lines setiap 5 menit
    for (int hour = 0; hour < 24; hour++) {
      for (int minute = 0; minute < 60; minute += minuteInterval) {
        bool isHourLine = minute == 0;
        bool isCurrentHour = isToday && hour == now.hour;
        double top = (hour * hourHeight) + (minute * hourHeight / 60);

        gridLines.add(
          Positioned(
            top: top,
            left: 0,
            right: 0,
            child: Container(
              height: hourHeight / (60 / minuteInterval),
              decoration: BoxDecoration(
                border: Border(
                  bottom: BorderSide(
                    color:
                        isHourLine
                            ? (isCurrentHour
                                ? Colors.blue
                                : Colors.grey.shade300)
                            : Colors.grey.shade100,
                    width: isHourLine ? (isCurrentHour ? 2 : 1) : 0.5,
                  ),
                ),
              ),
            ),
          ),
        );
      }
    }

    return Stack(children: gridLines);
  }

  Widget _buildOverlayDragTarget() {
    return Positioned.fill(
      child: Builder(
        builder: (context) {
          return DragTarget<CalendarEvent>(
            onMove: (details) {
              try {
                RenderBox? renderBox = context.findRenderObject() as RenderBox?;
                if (renderBox == null) return;

                Offset localOffset = renderBox.globalToLocal(details.offset);
                double localY = localOffset.dy;

                double hours = localY / hourHeight;
                int targetHour = hours.floor();
                int targetMinute = ((hours - targetHour) * 60).round();

                targetMinute =
                    (targetMinute ~/ minuteInterval) * minuteInterval;

                if (targetMinute >= 60) {
                  targetHour += 1;
                  targetMinute = 0;
                }

                if (targetHour >= 0 &&
                    targetHour < 24 &&
                    targetMinute >= 0 &&
                    targetMinute < 60) {
                  setState(() {
                    _isDragging = true;
                    _dragTargetTime = widget.selectedDate.copyWith(
                      hour: targetHour,
                      minute: targetMinute,
                    );
                  });
                }
              } catch (e) {
                print('Error in drag calculation: $e');
              }
            },
            onWillAcceptWithDetails: (data) {
              if (data.data != null) {
                setState(() {
                  _draggedEvent = data.data;
                });
              }
              return data.data != null;
            },
            onAcceptWithDetails: (details) {
              if (_dragTargetTime != null) {
                _moveEventToTime(details.data, _dragTargetTime!);
              }
              setState(() {
                _isDragging = false;
                _dragTargetTime = null;
                _draggedEvent = null;
              });
            },
            onLeave: (data) {
              setState(() {
                _isDragging = false;
                _dragTargetTime = null;
                _draggedEvent = null;
              });
            },
            builder: (context, candidateData, rejectedData) {
              bool isHighlighted = candidateData.isNotEmpty;
              return IgnorePointer(
                ignoring: !isHighlighted,
                child: Container(
                  color:
                      isHighlighted
                          ? Colors.blue.withValues(alpha: 0.08)
                          : Colors.transparent,
                  child:
                      isHighlighted
                          ? Container(
                            margin: const EdgeInsets.symmetric(horizontal: 4),
                            decoration: BoxDecoration(
                              border: Border.all(
                                color: Colors.blue.withValues(alpha: 0.4),
                                width: 2,
                              ),
                              borderRadius: BorderRadius.circular(4),
                            ),
                          )
                          : null,
                ),
              );
            },
          );
        },
      ),
    );
  }

  Widget _buildCurrentTimeIndicator() {
    DateTime now = DateTime.now();
    bool isToday =
        widget.selectedDate.day == now.day &&
        widget.selectedDate.month == now.month &&
        widget.selectedDate.year == now.year;

    if (!isToday) return const SizedBox.shrink();

    double topPosition =
        (now.hour * hourHeight) + ((now.minute / 60) * hourHeight);

    return Positioned(
      top: topPosition,
      left: 0,
      right: 0,
      child: Container(
        height: 2,
        color: Colors.red,
        child: Row(
          children: [
            Container(
              width: 8,
              height: 8,
              decoration: const BoxDecoration(
                color: Colors.red,
                shape: BoxShape.circle,
              ),
            ),
            Expanded(child: Container(height: 2, color: Colors.red)),
          ],
        ),
      ),
    );
  }

  List<Widget> _buildLayoutedEvents() {
    List<EventLayout> layouts = _calculateEventLayouts();
    return layouts.map((layout) => _buildDraggableEvent(layout)).toList();
  }

  List<EventLayout> _calculateEventLayouts() {
    if (events.isEmpty) return [];

    List<CalendarEvent> sortedEvents = List.from(events);
    sortedEvents.sort((a, b) => a.startTime.compareTo(b.startTime));

    List<EventLayout> layouts = [];
    List<List<CalendarEvent>> eventGroups = [];

    for (CalendarEvent event in sortedEvents) {
      bool addedToGroup = false;

      for (List<CalendarEvent> group in eventGroups) {
        bool hasOverlap = false;
        for (CalendarEvent groupEvent in group) {
          if (_eventsOverlap(event, groupEvent)) {
            hasOverlap = true;
            break;
          }
        }
        if (hasOverlap) {
          group.add(event);
          addedToGroup = true;
          break;
        }
      }

      if (!addedToGroup) {
        eventGroups.add([event]);
      }
    }

    for (List<CalendarEvent> group in eventGroups) {
      if (group.length == 1) {
        layouts.add(
          EventLayout(
            event: group[0],
            left: 0.0,
            width: 1.0,
            column: 0,
            totalColumns: 1,
          ),
        );
      } else {
        List<List<CalendarEvent>> columns = [];

        for (CalendarEvent event in group) {
          int targetColumn = -1;

          for (int i = 0; i < columns.length; i++) {
            bool canPlace = true;
            for (CalendarEvent existingEvent in columns[i]) {
              if (_eventsOverlap(event, existingEvent)) {
                canPlace = false;
                break;
              }
            }
            if (canPlace) {
              targetColumn = i;
              break;
            }
          }

          if (targetColumn == -1) {
            columns.add([]);
            targetColumn = columns.length - 1;
          }

          columns[targetColumn].add(event);
        }

        int totalColumns = columns.length;
        double columnWidth = 1.0 / totalColumns;

        for (int columnIndex = 0; columnIndex < columns.length; columnIndex++) {
          for (CalendarEvent event in columns[columnIndex]) {
            layouts.add(
              EventLayout(
                event: event,
                left: columnIndex * columnWidth,
                width: columnWidth,
                column: columnIndex,
                totalColumns: totalColumns,
              ),
            );
          }
        }
      }
    }

    return layouts;
  }

  bool _eventsOverlap(CalendarEvent event1, CalendarEvent event2) {
    return event1.startTime.isBefore(event2.endTime) &&
        event2.startTime.isBefore(event1.endTime);
  }

  Widget _buildDraggableEvent(EventLayout layout) {
    CalendarEvent event = layout.event;
    double top = _getEventTopPosition(event);
    double height = _getEventHeight(event);
    double leftPadding = 8;
    double rightPadding = 8;

    double screenWidth = MediaQuery.of(context).size.width;
    double availableWidth =
        screenWidth - timeColumnWidth - leftPadding - rightPadding;

    double eventWidth = (availableWidth * layout.width).clamp(
      80.0,
      availableWidth,
    );
    double eventLeft = leftPadding + (availableWidth * layout.left);

    if (eventLeft + eventWidth > screenWidth - rightPadding) {
      eventLeft = screenWidth - rightPadding - eventWidth;
    }

    return Positioned(
      top: top,
      left: eventLeft,
      width: eventWidth,
      height: height,
      child: LongPressDraggable<CalendarEvent>(
        data: event,
        onDragStarted: () {
          setState(() {
            _isDragging = true;
            _draggedEvent = event;
          });
        },
        onDragEnd: (details) {
          setState(() {
            _isDragging = false;
            _dragTargetTime = null;
            _draggedEvent = null;
          });
        },
        feedback: Material(
          elevation: 6,
          borderRadius: BorderRadius.circular(8),
          child: Container(
            width: eventWidth,
            height: height,
            decoration: BoxDecoration(
              color: event.color.withValues(alpha: 0.9),
              borderRadius: BorderRadius.circular(8),
              border: Border.all(color: Colors.white, width: 2),
            ),
            padding: const EdgeInsets.all(6),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisSize: MainAxisSize.min,
              children: [
                Flexible(
                  child: Text(
                    event.title,
                    style: const TextStyle(
                      color: Colors.white,
                      fontWeight: FontWeight.bold,
                      fontSize: 12,
                    ),
                    overflow: TextOverflow.ellipsis,
                    maxLines: 1,
                  ),
                ),
                if (height > 30)
                  Flexible(
                    child: Text(
                      '${_formatTime(event.startTime)} - ${_formatTime(event.endTime)}',
                      style: const TextStyle(
                        color: Colors.white70,
                        fontSize: 10,
                      ),
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
              ],
            ),
          ),
        ),
        childWhenDragging: Container(
          decoration: BoxDecoration(
            color: Colors.grey.withValues(alpha: 0.4),
            borderRadius: BorderRadius.circular(8),
            border: Border.all(color: Colors.grey.shade400, width: 2),
          ),
          child: Center(
            child: Icon(
              Icons.drag_handle,
              color: Colors.grey.shade600,
              size: 24,
            ),
          ),
        ),
        child: GestureDetector(
          onTap: () => _showEventDetails(event),
          child: Container(
            decoration: BoxDecoration(
              color: event.color,
              borderRadius: BorderRadius.circular(8),
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withValues(alpha: 0.15),
                  blurRadius: 4,
                  offset: const Offset(0, 2),
                ),
              ],
            ),
            padding: const EdgeInsets.all(6),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisSize: MainAxisSize.min,
              children: [
                Flexible(
                  child: Text(
                    event.title,
                    style: const TextStyle(
                      color: Colors.white,
                      fontWeight: FontWeight.bold,
                      fontSize: 11,
                    ),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
                if (height > 30)
                  Flexible(
                    child: Text(
                      '${_formatTime(event.startTime)} - ${_formatTime(event.endTime)}',
                      style: const TextStyle(
                        color: Colors.white70,
                        fontSize: 9,
                      ),
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildDragTimeIndicator() {
    if (_dragTargetTime == null) {
      return const SizedBox.shrink();
    }

    double startTimeY =
        (_dragTargetTime!.hour * hourHeight) +
        (_dragTargetTime!.minute * hourHeight / 60);

    if (_scrollController.hasClients) {
      startTimeY -= _scrollController.offset;
    }

    String timeText = _formatTime(_dragTargetTime!);
    if (_draggedEvent != null) {
      Duration eventDuration = _draggedEvent!.endTime.difference(
        _draggedEvent!.startTime,
      );
      DateTime newEndTime = _dragTargetTime!.add(eventDuration);
      timeText =
          '${_formatTime(_dragTargetTime!)} - ${_formatTime(newEndTime)}';
    }

    return Positioned(
      left: timeColumnWidth + 10,
      top: startTimeY - 25, // Dinaikkan 25px
      child: IgnorePointer(
        child: Material(
          color: Colors.transparent,
          elevation: 8,
          borderRadius: BorderRadius.circular(8),
          child: Container(
            constraints: BoxConstraints(
              maxWidth:
                  MediaQuery.of(context).size.width - timeColumnWidth - 40,
            ),
            padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
            decoration: BoxDecoration(
              color: Colors.black87,
              borderRadius: BorderRadius.circular(8),
              border: Border.all(color: Colors.white, width: 1),
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withValues(alpha: 0.5),
                  blurRadius: 8,
                  offset: const Offset(0, 3),
                ),
              ],
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(Icons.schedule, color: Colors.white, size: 14),
                const SizedBox(width: 6),
                Flexible(
                  child: Text(
                    timeText,
                    style: const TextStyle(
                      color: Colors.white,
                      fontSize: 11,
                      fontWeight: FontWeight.bold,
                    ),
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  double _getEventTopPosition(CalendarEvent event) {
    int hour = event.startTime.hour;
    int minute = event.startTime.minute;
    return (hour * hourHeight) + (minute * hourHeight / 60);
  }

  double _getEventHeight(CalendarEvent event) {
    Duration duration = event.endTime.difference(event.startTime);
    return (duration.inMinutes * hourHeight / 60).clamp(20.0, double.infinity);
  }

  void _moveEventToTime(CalendarEvent event, DateTime targetTime) {
    Duration eventDuration = event.endTime.difference(event.startTime);
    DateTime newEndTime = targetTime.add(eventDuration);

    setState(() {
      int index = events.indexWhere((e) => e.id == event.id);
      if (index != -1) {
        events[index] = event.copyWith(
          startTime: targetTime,
          endTime: newEndTime,
        );
      }
    });

    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(
          '${event.title} dipindah ke ${_formatTime(targetTime)} - ${_formatTime(newEndTime)}',
        ),
        duration: const Duration(seconds: 2),
        backgroundColor: Colors.green,
        behavior: SnackBarBehavior.floating,
      ),
    );
  }

  void _addNewEvent() {
    DateTime now = DateTime.now();
    CalendarEvent newEvent = CalendarEvent(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      title: 'Event Baru',
      startTime: widget.selectedDate.copyWith(
        hour: now.hour,
        minute: (now.minute ~/ minuteInterval) * minuteInterval,
      ),
      endTime: widget.selectedDate.copyWith(
        hour: now.hour + 1,
        minute: (now.minute ~/ minuteInterval) * minuteInterval,
      ),
      color: Colors.orange,
    );

    setState(() {
      events.add(newEvent);
    });
  }

  void _showEventDetails(CalendarEvent event) {
    showDialog(
      context: context,
      builder:
          (context) => AlertDialog(
            title: Text(event.title),
            content: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text('Mulai: ${_formatDateTime(event.startTime)}'),
                Text('Selesai: ${_formatDateTime(event.endTime)}'),
                const SizedBox(height: 16),
                const Text('Long press untuk drag & drop event'),
                const Text('Drop precision: 5 menit'),
              ],
            ),
            actions: [
              TextButton(
                onPressed: () {
                  setState(() {
                    events.removeWhere((e) => e.id == event.id);
                  });
                  Navigator.pop(context);
                },
                child: const Text('Hapus'),
              ),
              TextButton(
                onPressed: () => Navigator.pop(context),
                child: const Text('Tutup'),
              ),
            ],
          ),
    );
  }

  String _formatTime(DateTime dateTime) {
    return '${dateTime.hour.toString().padLeft(2, '0')}:${dateTime.minute.toString().padLeft(2, '0')}';
  }

  String _formatDateTime(DateTime dateTime) {
    return '${dateTime.day}/${dateTime.month}/${dateTime.year} ${_formatTime(dateTime)}';
  }
}

// Widget utama untuk demo
class CalendarApp extends StatelessWidget {
  const CalendarApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Day View Calendar',
      theme: ThemeData(primarySwatch: Colors.blue, useMaterial3: true),
      home: DayViewCalendar(selectedDate: DateTime.now()),
    );
  }
}

void main() {
  runApp(const CalendarApp());
}
